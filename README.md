doing everything all over again

## I. Basic Techniques

### 1. Introduction
- 1.1 Input and output
- 1.2 Working with numbers
- 1.3 Shortening code
- 1.4 Mathematics
- 1.5 Contests and resources

### 2. Time Complexity
- 2.1 Calculation rules
- 2.2 Complexity classes
- 2.3 Estimating efficiency
- 2.4 Maximum subarray sum

### 3. Sorting
- 3.1 Sorting theory
- 3.2 Sorting in C++
- 3.3 Binary search

### 4. Data Structures
- 4.1 Dynamic arrays
- 4.2 Set structures
- 4.3 Map structures
- 4.4 Iterators and ranges
- 4.5 Other structures
- 4.6 Comparison to sorting

### 5. Complete Search
- 5.1 Generating subsets
- 5.2 Generating permutations
- 5.3 Backtracking
- 5.4 Pruning the search
- 5.5 Meet in the middle

### 6. Greedy Algorithms
- 6.1 Coin problem
- 6.2 Scheduling
- 6.3 Tasks and deadlines
- 6.4 Minimizing sums
- 6.5 Data compression

### 7. Dynamic Programming
- 7.1 Introduction
- 7.2 Longest increasing subsequence
- 7.3 Edit distance
- 7.4 Counting tilings
- 7.5 Paths in a grid
- 7.6 Dynamic programming optimization
- 7.7 Bitmask dynamic programming
- 7.8 DP and complete search

## II. Data Structures

### 8. Range Queries
- 8.1 Prefix sums
- 8.2 Binary indexed tree
- 8.3 Segment tree
- 8.4 Range minimum queries
- 8.5 2D range queries

### 9. Tree Algorithms
- 9.1 Depth-first search
- 9.2 Breadth-first search
- 9.3 Tree traversal
- 9.4 Lowest common ancestor
- 9.5 Rerooting technique
- 9.6 Counting paths in a tree

### 10. Hashing
- 10.1 Hash functions
- 10.2 String hashing
- 10.3 Collisions
- 10.4 Polynomial hashing
- 10.5 Applications

### 11. Geometry
- 11.1 Geometry basics
- 11.2 Line intersection
- 11.3 Polygon area
- 11.4 Point in polygon
- 11.5 Convex hull
- 11.6 Sweep line
- 11.7 Closest pair

## III. Graph Algorithms

### 12. Graph Representation
- 12.1 Adjacency lists
- 12.2 Adjacency matrix
- 12.3 Edge list

### 13. Graph Traversal
- 13.1 Depth-first search
- 13.2 Breadth-first search
- 13.3 Connected components
- 13.4 Cycles and bipartite graphs

### 14. Shortest Paths
- 14.1 Dijkstra’s algorithm
- 14.2 Bellman-Ford algorithm
- 14.3 Floyd-Warshall algorithm
- 14.4 0-1 BFS
- 14.5 Grid paths

### 15. Tree Algorithms
- 15.1 Tree basics
- 15.2 Tree traversal
- 15.3 Lowest common ancestor
- 15.4 Distance queries
- 15.5 Tree isomorphism

### 16. Topological Sorting
- 16.1 Theory
- 16.2 Algorithms
- 16.3 Cycle detection
- 16.4 Applications

### 17. Strong Connectivity
- 17.1 Strongly connected components
- 17.2 Kosaraju’s algorithm
- 17.3 Applications

### 18. Bridges and Articulation Points
- 18.1 Bridges
- 18.2 Articulation points
- 18.3 2-edge and 2-vertex connectivity

### 19. Network Flow
- 19.1 Flow networks
- 19.2 Ford-Fulkerson algorithm
- 19.3 Edmonds-Karp algorithm
- 19.4 Dinic’s algorithm
- 19.5 Minimum cut

### 20. Matching
- 20.1 Bipartite graphs
- 20.2 Maximum matching
- 20.3 Hopcroft-Karp algorithm
- 20.4 General graphs

## IV. Additional Topics

### 21. Number Theory
- 21.1 Prime numbers
- 21.2 Sieve of Eratosthenes
- 21.3 Modular arithmetic
- 21.4 Greatest common divisor
- 21.5 Extended Euclidean algorithm
- 21.6 Modular inverse
- 21.7 Diophantine equations
- 21.8 Euler’s totient function
- 21.9 Discrete logarithm

### 22. Combinatorics
- 22.1 Combinations and permutations
- 22.2 Binomial coefficients
- 22.3 Catalan numbers
- 22.4 Inclusion-exclusion principle
- 22.5 Stirling numbers

### 23. Game Theory
- 23.1 Grundy numbers
- 23.2 Sprague-Grundy theorem
- 23.3 Nim game

### 24. Bit Manipulation
- 24.1 Basic operations
- 24.2 Bit hacks
- 24.3 Applications

### 25. Advanced Techniques
- 25.1 Segment tree beats
- 25.2 Mo’s algorithm
- 25.3 Centroid decomposition
- 25.4 Heavy-light decomposition
- 25.5 Suffix arrays
- 25.6 Suffix automaton
